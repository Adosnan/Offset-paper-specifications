关于胶印印刷相关计算方案的建议
定义四个函数
0.计算流程
1-2-3-4

预设参数：
开料最大尺寸[纵，横]cut_max = [603,735]
开料最小尺寸[纵，横]cut_min = [340,350]
横切可能纸张宽度 paper_list = [797,910,920,930,945,950,955,960,980,1000,1005,1045,1050,1200,1220]

输入样式[碗盖宽，碗盖长，碗盖的横出血，碗盖的纵出血] 
如：[141,141,4,4]；
输出样式[碗盖宽，碗盖长，横出血，纵出血，印张尺寸1，印张尺寸2，拼数1，拼数2，原纸规格，横切规格，飞边，利用率，生产效率]
如[141,141,4,4,593*728,593*728,20,20,1200,1200*730,14,96.0%,100.0%]
  [102,102,4,4,543*639,437*639,30,24,1000,1000*641,20,94.7%,90.0%]
1.碗盖的规格及纸张宽度
函数名：Bowllid_list_temp
本函数重点在于计算纵排数的可能性及在处理方形碗盖(即碗盖长宽不相等)的准备工作
如输入参数[183,163,4,4],1000
输出参数[碗盖出血后的宽，碗盖出血后的长，横排1，横排2，纵排可能性，原纸宽度，碗盖宽，碗盖长]
[[187, 167, 3, 2, [3, 4], 1045, 183, 163], 
[167, 187, 3, 3, [2, 3], 1045, 163, 183]]
1.1输入参数
1)碗盖的宽：x
2)碗盖的长：y
3)碗盖横出血：w_x - x
4)碗盖纵出血：w_y - y
5)纸张宽度：paper_width
6)最小上纸宽：cut_min[0]
7)最大上纸宽：cut_max[1]
1.2输出参数
1)碗盖出血后规格宽：w_x
2)碗盖出血后规格长：w_y
3)横排1：x_1
4)横排2：x_2
5)纵排的可能性：y_list
6)原纸宽度：p
7)碗盖规格宽：x
8)碗盖规格长：y
1.3情况讨论
第一种：圆盖
第二种：方盖
由于圆盖长宽相等，故仅需要讨论一种情况；但方盖有长和宽，所以需要在圆盖的情况下附加上长宽颠倒的情况
1.4逻辑原理
纵排最小值：y_min = 向下取整(cut_min[0]/w_y) + 1
纵排最大值：y_max = 向下取整(cut_max[1]/w_y)
横排1：向下取整((p -16)/ w_x) – 向下取整(下向取整((p – 16) / w_x)/2)
横排2：下向取整((p -16) / w_x) – x_1
当碗盖的长宽不相等时，将长宽及对应出血颠倒后写入
1.5注意事项
1)此函数涉及到处理二维数组及浮点数，由于浮点数在计算机内存机制问题，需要添加判断，我在本函数中使用判断如下：
如果 w_x = 向下取整(w_x)
那么 w_x = 向下取整(w_x)
不然的话输出“请核对X出血是否准确”并且结束程序
2)由于横排需要在碗盖出血后排版的基础上至少加上6mm印刷飞边及10mm开料飞边，所以在计算x_1 的时候需要减去16mm
2.计算单个纸张宽度下在不同纵排的可能性 
函数名：Bowl_specifications_list_temp
本函数通过上一函数的输出值，如：
[[187, 167, 3, 2, [3, 4], 1045, 183, 163],
[167, 187, 3, 3, [2, 3], 1045, 163, 183]]
计算得出本函数的输出值：
[碗盖的宽，碗盖的长，碗盖出血后规格宽，碗盖出血后规格长，原纸宽度，横排1宽，纵排长，横排2宽，纵排长，总横排后的飞边，纸张利用率]
[[183, 163, 187, 167, 1045, 574, 671, 387, 671, 84, 0.8881],
[163, 183, 167, 187, 1045, 504, 387, 504, 387, 37, 0.9219], 
[163, 183, 167, 187, 1045, 514, 564, 514, 564, 17, 0.9504]]
2.1输入参数
1)碗盖出血后规格宽：w_x
2)碗盖出血后规格长：w_y
3)横排1：x_1
4)横排2：x_2
5)纵排可能性：y_list
6)原纸宽度：p
7)碗盖的宽：w_x_1
8)碗盖的长：w_y_1
2.2输出参数
1)碗盖的规格宽：w_x_1
2)碗盖的规格长：w_y_1
3)碗盖的出血后规格宽：w_x
4)碗盖的出血后规格长：w_y
5)原纸的宽度：p
6)横排1的宽度：temp_x_1
7)横排2的宽度：temp_x_2
8)纵排的长度：temp_y
9)整个横排飞边：temp_x_0
10)印刷面积利用率：temp_area
2.3逻辑原理
排除y_list中x_1，x_2，并穷举y_list的所有值，定义为：i
单独考虑i的值等于x_1的可能性
2.3.1穷举y_list所有值
将求出的数组带入temp_Bowllid_build_list 数组中
2.3.1.1 y_list的长度不为0
	定义一个空的数组temp_Bowllid_build_list，用于接收可能性
条件：i < x_1
temp_x = (x_1 + x_2) *w_x + 3*2
如果 temp_x + 10 ≤ p 的话，
	temp_y = i * w_y + 13
	temp_x_1 = x_1 * w_x + 3
	temp_x_2 = x_2 * w_x + 3
	temp_x_0 = p - temp_x
条件：i > x_1
temp_x = (x_1 + x_2) * w_x + 13*2
如果 temp_x + 10 <= p 的话，
	temp_y = I * w_y + 3
	temp_x_1 = x_1 * w_x + 13
	temp_x_2 = x_2 * w_x + 13
	temp_x_0 = p – temp_x
如果 temp_x + 10 > p的话
	如果 x_1 == x_2的话
		x_2 = x_2 – 1
		temp_x = (x_1 + x_2) * w_x + 13*2
		如果temp_x + 10 <= p的话
			temp_y = i*w_y + 3
			temp_x_0 = p -temp_x
temp_x_1 = x_1 * w_x + 13
temp_x_2 = x_2 * w_x + 13
			如果x_1 != x_2的话
				x_1 = x_1 – 1
temp_x = (x_1 + x_2) * w_x + 13*2
如果temp_x + 10 <= p的话
	temp_y = i * w_y + 3
	temp_x_0 = p – temp_x
	temp_x_1 = x_1 * w_x + 13
	temp_x_2 = x_2 * w_x + 13
碗盖应占用面积：temp_area_1 = (x_1 + x_2) * i * w_x * w_y
纸张使用面积：temp_area_2 = (temp_y +2) * p
temp_area = 取四位小数(temp_area_1 / temp_area_2)
2.3.1.2 y_list的长度为0
将所有需要计算的值均填为0；
2.3.2 i的特殊情况
i = x_1
如果 y_list的长度不等于0，并且 i>=min(y_list)的话
temp_x = (x_1 + x_2) * w_x
定义一个空数组Bowllid_build 
如果 temp_x + 2*13 +10 ≤ p的话
	temp_y = i * w_x + 3
	temp_x_0 = p – temp_x -2*13
	temp_x_1 = x_1 * w_x +13
	temp_x_2 = x_2 * w_x +13
如果 temp_x + 2*3 + 10 ≤ p 的话
	temp_y = i * w_y + 13
	temp_x_0 = p -temp_x -2*3
	temp_x_1 = x_1 * w_x +3
	temp_x_2 = x_2 * w_x + 3
碗盖应占用面积：temp_area_1 = (x_1 + x_2) * i * w_x * w_y
纸张使用面积：temp_area_2 = (temp_y +2) * p
temp_area = 取四位小数(temp_area_1 / temp_area_2)
2.3.3输出内容
1).将2.3.1、2.3.2中的参数输出到一维数组Bowllid_build中；
2).判断Bowllid_build是否为空值，如果不为空则继续：
3).将Bowllid_build输出到二维数组temp_Bowllid_build_list中。
4).将temp_Bowllid_build_list中满足印刷进纸规格的保留带入新的数组Bowllid_build_list
5).如果Bowllid_build_list的长度为0，则将所有计算的值以0代替，防止后续函数中计算时报错
3.选择最优的开料规格
函数名：Bowllid_list
本函数通过上一函数输出值：
[[183, 163, 187, 167, 1045, 574, 671, 387, 671, 84, 0.8881], 
[163, 183, 167, 187, 1045, 504, 387, 504, 387, 37, 0.9219],
[163, 183, 167, 187, 1045, 514, 564, 514, 564, 17, 0.9504]]
本函数的输出值：
[163, 183, 167, 187, 1045, 514, 564, 514, 564, 17, 0.9504]
3.1输入参数
二维数组Bowllid_build_list
3.2输出参数
二维数组Bowllid_build_list
3.3逻辑原理
将二维数组中的temp_area 写入area_temp 一维数组中；
横排1的宽度：x_1
纵排的长度：y
印刷面积利用率：area
如果横排1和纵排的长度相差10mm，并且该记录area对应一维数组area_temp的最大值；
则最优解就是该条记录
穷举Bowllid_build_list中的所有记录
	如果area_temp的长度为空值，则跳出
	如果area == area_temp中的最大值，
		那么最优解替换为此条记录
4.开料规格的标准化输出
函数名：Bowllid_list
本函数通过上一函数的输出值：
[163, 183, 167, 187, 1045, 514, 564, 514, 564, 17, 0.9504]
本函数的输出值：
[163, 183, 4, 4, '514*564', '514*564', 9, 9, 1045, '1045*566', 17, 0.9504, 0.75]
4.1输入参数
1)碗盖的宽：x
2)碗盖的长：y
3)碗盖出血后宽：w_x
4)碗盖出血后长：w_y
5)原纸的宽度：p
6)横排1的宽度：w_x_1
7)横排2的宽度：w_x_2
8)纵排的长度：temp_y
9)整个横排的飞边：w_x_0
10)印刷面积利用率：area
4.2输出参数
1)碗盖的宽：x
2)碗盖的长：y
3)碗盖的横出血：w_x - x
4)碗盖的纵出血：w_y - y
5)开料规格1：w_x_1 * temp_y  此处乘法不需要计算
6)开料规格2：w_x_2 * temp_y  此处乘法不需要计算
7)拼数1 cut_1_num = 向下取整(w_x_1 / w_x) * 向下取整(temp_y / w_y)
8)拼数2 cut_2_num = 向下取整(w_x_2 / w_x) * 向下取整(temp_y / w_y)
9)原纸规格：p
10)横切规格：p * (temp_y + 2) 此处乘法不需要计算
11)整个横排飞边：w_x_0
12)印刷面积利用率：area
13)生产效率：(cut_1_num + cut_2_num)/max_cut_num
4.3逻辑原理
#最大印刷拼数
max_cut_num_1 = 向下取整(cut_max[1] / w_x) * 向下取整(cut_max[0]/w_y)
max_cut_num_2 = 向下取整(cut_max[1] / w_y) * 向下取整(cut_max[1]/w_x)
max_cut_num = max(max_cut_num_1,max_cut_num_2)
